
辗转相除法：  如果两个正整数 a,b (a> b)， 他们的最大公约数 等于  a 除以b 的余数 c  和  b 之间 最大的公约数。   `f(a,b) = f(b,c)  (c = a % b)` ----- 时间复杂度 `O(log(max(a, b)))`
更相减损术：  如果两个正整数 a,b (a> b)， 他们的最大公约数 等于  a 减去b 的差 c  和  b 之间 最大的公约数。   `f(a,b) = f(b,c)  (c = a - b)`----- 时间复杂度 `O(max(a, b))`

取模 比较 耗时，  用 减法 ；
用 减法 不稳定， 如 计算 10000, 1 就要递归 9999 次。
可以将 两者结合起来----- 时间复杂度 `O(log(max(a, b)))`

同时，  get_great_common_divison( a, b) ===>  gcd(a,b)

当 a 偶数，b 偶数， `gcd(a,b) = 2 * gcd(a/2, b/2) = 2 * gcd(a>>1, b>>1) `
当 a 奇数，b 偶数， `gcd(a,b) = gcd(a, b/2) = 2 * gcd(a, b>>1)` 
当 a 偶数，b 奇数， `gcd(a,b) = gcd(a/2, b) = 2 * gcd(a>>1, b)` 
当 a 奇数，b 奇数， 先 更相减损术： `gcd(a,b) = gcd(b, b-c)` ， 此时 a-b 必然是偶数 ， 用上面的 方式

用  `a & 1 == 0`  来 判断 奇数偶数。
